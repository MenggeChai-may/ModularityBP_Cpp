.. CHAMP documentation master file, created by
   sphinx-quickstart on Tue Jul 11 15:50:43 2017.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

=================================
Louvain Parallel Extension
=================================

CHAMP can be used with partitions generated by any community detection algorithm.  One of the most popular \
and fast algorithms is known as Louvain :cite:`Blondel:2008vn` .  We provide an extension to the python package \
developed by Vincent Traag, `louvain_igraph <https://github.com/vtraag/louvain-igraph>`_  :cite:`traag_louvain` to \
run Louvain in parallel, while calculating the coefficients necessary for CHAMP.  Currently, this extension only \
support single-layer network.  The random seed is set within each parallel process to ensure that the results are
stochastic over each run.  In general this is desireable because Louvain uses a greedy optimization schema that \
finds *local* optima.



.. autofunction:: champ.louvain_ext.parallel_louvain


We also have created a convenient class for managing and merging groups of partitions \
called :mod:`champ.louvain_ext.PartitionEnsemble` .  This class stores the partitions in membership vector form \
( i.e. a list of N community assignments), as well as the coefficients for the partitions.  As part of its class \
methods, the PartitionEnsemble is able to apply CHAMP to its own partitions and store their domains.

.. _`louvain_ext.PartitionEnsemble`:
.. autoclass:: champ.louvain_ext.PartitionEnsemble
    :members:

--------
Partition Ensemble Example
--------
We use igraph to generate a random ER graph, call louvain in parallel, and apply CHAMP to the ensemble.
::

    import champ
    from champ import louvain_ext

    import igraph as ig
    import tempfile
    import numpy as np
    import matplotlib.pyplot as plt

    np.random.seed(0)
    test_graph=ig.Graph.Erdos_Renyi(500,p=.05)
    #Create temporary file for calling louvain
    tfile=tempfile.NamedTemporaryFile('wb')
    test_graph.write_graphmlz(tfile.name)

    #non-parallelized wrapper
    ens1=louvain_ext.run_louvain(tfile.name,nruns=30,gamma=1)

    #parallelized wrapper
    ens2=louvain_ext.parallel_louvain(test_graph,
                                      numruns=10,
                                      numprocesses=2,
                                      progress=True)

    #Output as gzipped file
    ens2.save("test_esemble_file.gz")



    #Apply Champ to Coefficients
    coeffs2=ens2.get_coefficient_array()
    ind2dom2=champ.get_intersection(coeffs2)
    plt.close()
    ax=champ.plot_single_layer_modularity(ind2dom2)
    plt.show()

References
___________

.. bibliography:: biblio.bib
    :style: plain
    :filter: docname in docnames




* :ref:`genindex`
* :ref:`search`

